import * as React from "react";
import { DragDropEffect, dispatchCustomDragEvent } from '../Utilities/DragDrop';
import { ObservableValue } from '../Core/Observable';
import { Portal } from '../Portal';
import { css, getPointByEventType, Pointer } from "../Util";
import { distance } from "./Position";
var DragDropManagerOptimized = /** @class */ (function () {
    function DragDropManagerOptimized() {
        var _this = this;
        this.onEventCaptured = function (event) {
            // Handle the pointerup and pointermove events
            var type = event.type;
            if (type === "pointermove") {
                // For pointermove events, if there is no drag in progress, we need to check to see if the pointer
                // has moved far enough to meet our threshold for triggering a drag/drop operation.
                if (!_this.dragInProgress) {
                    if (_this.potentialDragInProgress) {
                        var coordinates = getPointByEventType(event);
                        if (distance(_this.initialCoordinates, coordinates) > _this.minimumPixelsForDrag) {
                            // The position of the pointer is far enough away from our threshold to trigger a drag event.
                            // Fire the dragstart event to give the drag source an opportunity to cancel the operation
                            dispatchCustomDragEvent("dragstart", _this.dragSourceElement, event, _this.dataTransfer);
                            if (_this.dataTransfer.effectAllowed === DragDropEffect.none) {
                                _this.potentialDragInProgress = false;
                                _this.endDrag();
                            }
                            else {
                                _this.dragInProgress = true;
                                if (_this.operation) {
                                    _this.operation.value = { x: coordinates.x, y: coordinates.y };
                                }
                            }
                            event.preventDefault();
                        }
                    }
                    // If there isn't the potential for a drag, that means a consumer has already
                    // indicated that we should cancel this drag event, so there is no need to continue to
                    // check anything about this event.
                }
                else {
                    // If there is a drag in progress, treat this as a dragover event.
                    var target = _this.getTargetFromEvent(event);
                    if (target) {
                        var coordinates = getPointByEventType(event);
                        if (_this.operation) {
                            _this.operation.value = { x: coordinates.x, y: coordinates.y };
                        }
                        dispatchCustomDragEvent("dragover", target, event, _this.dataTransfer);
                        event.preventDefault();
                    }
                }
            }
            else if (type === "pointerup") {
                if (_this.dragInProgress) {
                    var target = _this.getTargetFromEvent(event);
                    // Always fire the dragend event when we get a pointerup, if there was a drag in progress.
                    dispatchCustomDragEvent("dragend", _this.dragSourceElement, event, _this.dataTransfer);
                    if (target && _this.dataTransfer.dropEffect !== DragDropEffect.none) {
                        // Only fire a drop event if the dropEffect allows it.
                        dispatchCustomDragEvent("drop", target, event, _this.dataTransfer);
                    }
                }
                _this.endDrag();
            }
        };
        this.onPointerLeave = function (event) {
            // The pointer has left the bounds of the body element, so a drop is not
            // viable at this point.
            _this.dataTransfer.dropEffect = DragDropEffect.none;
        };
        this.onPointerOut = function (event) {
            if (event.target) {
                // The pointer has left an element, so we need to set the dropEffect to none.
                // The dragover event will fire, giving a new drop target the chance to
                // reset the effect.
                _this.dataTransfer.dropEffect = DragDropEffect.none;
                dispatchCustomDragEvent("dragexit", event.target, event, _this.dataTransfer);
            }
        };
        this.onPointerOver = function (event) {
            if (event.target) {
                // The pointer has entered an element, so we need to set the dropEffect to none.
                // The dragover event will fire, giving a new drop target the chance to
                // reset the effect.
                _this.dataTransfer.dropEffect = DragDropEffect.none;
                dispatchCustomDragEvent("dragenter", event.target, event, _this.dataTransfer);
            }
        };
    }
    DragDropManagerOptimized.prototype.beginDragOperationOptimized = function (event, dataTransfer, minimumPixelsForDrag) {
        if (minimumPixelsForDrag === void 0) { minimumPixelsForDrag = 4; }
        this.operation = undefined;
        // Something (typically a pointdown on a drag source) has indicated that there is the potential
        // for a drag operation. If there is a drag operation already in progress, do nothing.
        if (!this.dragInProgress) {
            // If there is no drag operation in progress, we should set up the event handlers to detect pointer
            // operations that could lead us to actually start the drag / drop operation.
            if (event.type === "pointerdown") {
                this.startDrag(event, minimumPixelsForDrag, dataTransfer);
                this.initialCoordinates = {
                    x: event.clientX,
                    y: event.clientY
                };
                Pointer.setCapture(this.onEventCaptured);
                document.body.addEventListener("pointerout", this.onPointerOut, true);
                document.body.addEventListener("pointerover", this.onPointerOver, true);
                document.body.addEventListener("pointerleave", this.onPointerLeave);
                this.operation = new ObservableValue({ x: undefined, y: undefined });
            }
        }
        return this.operation;
    };
    Object.defineProperty(DragDropManagerOptimized.prototype, "isDragInProgress", {
        get: function () {
            return this.dragInProgress;
        },
        enumerable: false,
        configurable: true
    });
    DragDropManagerOptimized.prototype.endDrag = function () {
        document.body.removeEventListener("pointerout", this.onPointerOut);
        document.body.removeEventListener("pointerover", this.onPointerOver);
        document.body.removeEventListener("pointerleave", this.onPointerLeave);
        this.dragInProgress = false;
    };
    DragDropManagerOptimized.prototype.getTargetFromEvent = function (event) {
        return event.target;
    };
    DragDropManagerOptimized.prototype.startDrag = function (event, minimumPixelsForDrag, dataTransfer) {
        this.potentialDragInProgress = true;
        this.dragSourceElement = event.target;
        this.minimumPixelsForDrag = minimumPixelsForDrag;
        this.dataTransfer = dataTransfer;
    };
    return DragDropManagerOptimized;
}());
var dragDropManagerOptimized = new DragDropManagerOptimized();
export function beginDragOperationOptimized(event, dataTransfer, minimumPixelsForDrag) {
    return dragDropManagerOptimized.beginDragOperationOptimized(event, dataTransfer, minimumPixelsForDrag);
}
export var DragImageOptimized = React.memo(function (props) {
    var className = props.className, operation = props.operation, _a = props.xOffset, xOffset = _a === void 0 ? 5 : _a, _b = props.yOffset, yOffset = _b === void 0 ? 5 : _b;
    var dragImageRef = React.useRef(null);
    var dragImageFrameId = React.useRef(0);
    var updatePosition = function () {
        cancelAnimationFrame(dragImageFrameId.current);
        dragImageFrameId.current = requestAnimationFrame(function () {
            var _a;
            if (!((_a = dragImageRef.current) === null || _a === void 0 ? void 0 : _a.style) || !operation.value || !operation.value.x || !operation.value.y) {
                // either the drag image is not mounted or no DnD coordinates are available => can't update position
                return;
            }
            var xOffsetPx = operation.value.x + xOffset;
            var yOffsetPx = operation.value.y + yOffset;
            dragImageRef.current.style.transform = "translate3d(".concat(xOffsetPx, "px, ").concat(yOffsetPx, "px, 0)");
        });
    };
    React.useEffect(function () {
        operation.subscribe(updatePosition);
        return function () {
            operation.unsubscribe(updatePosition);
        };
    }, []);
    return (React.createElement(React.Fragment, null,
        React.createElement(Portal, { className: "bolt-drag-image-portal" },
            React.createElement("div", { className: css(className, "bolt-drag-image depth-16 absolute flex-row flex-center scroll-hidden justify-center"), ref: dragImageRef }, props.children))));
});
