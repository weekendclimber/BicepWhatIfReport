import { __extends } from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./Sizer.css";
import * as React from "react";
import { ObservableLike } from '../../Core/Observable';
import { TimerManagement } from '../../Core/TimerManagement';
import { Observer } from '../../Observer';
import { css, KeyCode, Mouse } from '../../Util';
import { Orientation, Position } from "./Sizer.Props";
import { Tooltip } from '../../TooltipEx';
import * as Resources from '../../Resources.Widgets';
import { Button } from '../../Button';
import { Location } from '../../Utilities/Position';
import { Callout } from '../../Callout';
var Sizer = /** @class */ (function (_super) {
    __extends(Sizer, _super);
    function Sizer(props) {
        var _this = _super.call(this, props) || this;
        _this.sizerRef = React.createRef();
        _this.sizerCalloutRef = React.createRef();
        _this.lastLocation = -1;
        _this.timerManagement = new TimerManagement();
        _this.isSizerSortingFixFFEnabled = false;
        _this.state = { showPortal: false, resizeInProgress: false, lastTouchLocation: 0, resizeButtonsUsed: false };
        _this.onDragStart = function (event) {
            // Prevent default to stop the ColumnDragDropBehavior from trying to handle this event.
            event.preventDefault();
            _this.setState({ showPortal: false });
            Mouse.setCapture(_this.onMouseCapture);
        };
        _this.onDragEnd = function (event) {
            Mouse.releaseCapture(_this.onMouseCapture);
        };
        _this.onDragEquivalentButtonClick = function (event, direction) {
            event.preventDefault();
            _this.setState({ resizeButtonsUsed: true, resizeInProgress: true });
            _this.updateSize(event, direction, true);
            _this.onSizeEnd();
        };
        _this.onMouseCapture = function (event) {
            var _a, _b;
            var locationTouchDiff = _this.getMouseLocation(event) - _this.state.lastTouchLocation;
            // Recompute the size and update the lastLocation based on the amount changed.
            _this.lastLocation += _this.updateSize(event, _this.getMouseLocation(event) - _this.lastLocation);
            // Remove the portal now that we are no longer sizing.
            if (event.type === "mouseup") {
                if (_this.isSizerSortingFixFFEnabled) {
                    event.preventDefault();
                    event.stopPropagation();
                    document.body.setAttribute('data-resize-active', 'false');
                    setTimeout(function () {
                        document.body.removeAttribute('data-resize-active');
                    }, 0);
                }
                if (locationTouchDiff !== 0) {
                    _this.setState({ resizeInProgress: false, showPortal: false });
                    var focuselt = (_a = _this.sizerRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
                    focuselt === null || focuselt === void 0 ? void 0 : focuselt.blur();
                }
                else if (_this.state.resizeInProgress) {
                    _this.setState({ showPortal: true });
                    var focuselt = (_b = _this.sizerRef.current) === null || _b === void 0 ? void 0 : _b.parentElement;
                    focuselt === null || focuselt === void 0 ? void 0 : focuselt.focus();
                }
                else {
                    _this.setState({ showPortal: false });
                }
                // If the user wanted to know when the sizing was complete, we will notify
                // the now that sizing is complete.
                _this.onSizeEnd();
            }
        };
        _this.onKeyDown = function (event) {
            var _a;
            if (!event.defaultPrevented) {
                var orientation_1 = _this.props.orientation;
                var sizeChange = void 0;
                _this.setState({ resizeInProgress: true });
                if (orientation_1 === Orientation.row) {
                    if (event.which === KeyCode.enter) {
                        var focuselt = (_a = _this.sizerRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
                        focuselt === null || focuselt === void 0 ? void 0 : focuselt.focus();
                    }
                    if (event.which === KeyCode.leftArrow) {
                        sizeChange = _this.updateSize(event.nativeEvent, -1, true);
                    }
                    else if (event.which === KeyCode.rightArrow) {
                        sizeChange = _this.updateSize(event.nativeEvent, 1, true);
                    }
                }
                else {
                    if (event.which === KeyCode.upArrow) {
                        sizeChange = _this.updateSize(event.nativeEvent, -1, true);
                    }
                    else if (event.which === KeyCode.downArrow) {
                        sizeChange = _this.updateSize(event.nativeEvent, 1, true);
                    }
                }
                // If we changed the size, we will prevent the default and start a
                // timer to end the sizing operation. Since there is no gesture to
                // start and complete with the keyboard.
                if (sizeChange) {
                    event.preventDefault();
                    _this.debouncedEnd();
                }
            }
        };
        _this.onSizeEnd = function () {
            if (_this.props.onSizeEnd) {
                _this.props.onSizeEnd(_this.props.id);
            }
        };
        _this.onMouseDown = function (event) {
            // Look for only main button clicks, not right click
            if (!event.defaultPrevented && event.button === 0 && event.currentTarget === _this.sizerRef.current) {
                if (_this.isSizerSortingFixFFEnabled) {
                    document.body.setAttribute('data-resize-active', 'true');
                }
                _this.lastLocation = _this.getMouseLocation(event.nativeEvent);
                if (!_this.state.resizeInProgress) {
                    _this.setState({ lastTouchLocation: _this.lastLocation, resizeInProgress: true });
                }
                // Capture the mouse, this will let us size the column when dragging.
                Mouse.setCapture(_this.onMouseCapture);
                // Show the portal that keeps our sizing actions for effecting the other elements.
                _this.setState({ showPortal: true });
                // Don't let the event set focus or start a mouse selection.
                event.preventDefault();
            }
        };
        _this.debouncedEnd = _this.timerManagement.debounce(_this.onSizeEnd, 500, { trailing: true });
        _this.handleClickOutside = _this.handleClickOutside.bind(_this);
        _this.isSizerSortingFixFFEnabled = document.body.classList.contains('sizer-sorting-fix-ff-enabled');
        return _this;
    }
    Sizer.prototype.render = function () {
        var _this = this;
        var divider = this.props.divider;
        return (React.createElement(Tooltip, { text: Resources.SizerAnnouncement, anchorOffset: { horizontal: 0, vertical: 30 }, anchorOrigin: { horizontal: Location.center, vertical: Location.start } },
            React.createElement("div", { "aria-label": this.props.ariaLabel || Resources.SizerAnnouncement, "aria-valuetext": "".concat(ObservableLike.getValue(this.props.size), " pixels wide"), "aria-valuenow": ObservableLike.getValue(this.props.size), className: css(this.props.className, "bolt-sizer", (this.state.resizeInProgress || this.state.showPortal) && 'bolt-sizer-active', this.props.orientation === Orientation.row ? "bolt-sizer-row flex-row" : "bolt-sizer-column flex-column", divider && "divider"), id: this.props.id, onKeyDown: this.onKeyDown, onMouseDown: this.onMouseDown, onDragStart: this.onDragStart, onDragEnd: this.onDragEnd, ref: this.sizerRef, role: "separator", tabIndex: this.props.tabIndex }, this.state.showPortal && (React.createElement(React.Fragment, null,
                React.createElement(Callout, { anchorElement: this.sizerRef.current, anchorOffset: { horizontal: 0, vertical: -50 }, anchorOrigin: { horizontal: Location.start, vertical: Location.start }, calloutOrigin: { horizontal: Location.center, vertical: Location.start }, contentShadow: true, viewportChangeDismiss: false },
                    React.createElement("div", { className: "flex-row bolt-sizer-callout-row", ref: this.sizerCalloutRef },
                        React.createElement(Button, { ariaLabel: Resources.ColumnButtonSizerLeftAriaLabel, className: "icon-only bolt-sizer-resize-button", iconProps: { iconName: "ChevronLeft" }, tooltipProps: {
                                anchorOrigin: { horizontal: Location.center, vertical: Location.end },
                                anchorOffset: { horizontal: 0, vertical: -70 },
                                text: Resources.ColumnButtonSizerLeft
                            }, onMouseDown: function (e) { return e.stopPropagation(); }, onClick: function (event) { return _this.onDragEquivalentButtonClick(event.nativeEvent, -1); } }),
                        React.createElement(Button, { ariaLabel: Resources.ColumnButtonSizerRightAriaLabel, className: "icon-only bolt-sizer-resize-button", iconProps: { iconName: "ChevronRight" }, tooltipProps: {
                                anchorOrigin: { horizontal: Location.center, vertical: Location.end },
                                anchorOffset: { horizontal: 0, vertical: -70 },
                                text: Resources.ColumnButtonSizerRight
                            }, onMouseDown: function (e) { return e.stopPropagation(); }, onClick: function (event) { return _this.onDragEquivalentButtonClick(event.nativeEvent, 1); } }))))))));
    };
    Sizer.prototype.componentDidMount = function () {
        document.addEventListener("mousedown", this.handleClickOutside);
    };
    Sizer.prototype.componentWillUnmount = function () {
        Mouse.releaseCapture(this.onMouseCapture);
        document.removeEventListener("mousedown", this.handleClickOutside);
        if (this.isSizerSortingFixFFEnabled) {
            document.body.removeAttribute('data-resize-active');
        }
    };
    Sizer.prototype.getMouseLocation = function (event) {
        return this.props.orientation === Orientation.row ? event.pageX : event.pageY;
    };
    Sizer.prototype.handleClickOutside = function (event) {
        var _a;
        var composedPathArray = Array.from(event.composedPath());
        var isInComposedPath = composedPathArray.includes(this.sizerCalloutRef.current);
        if (this.state.resizeInProgress && this.getMouseLocation(event) !== this.state.lastTouchLocation && !isInComposedPath) {
            this.setState({
                resizeInProgress: false,
                showPortal: false,
                resizeButtonsUsed: false,
            });
            var focuselt = (_a = this.sizerRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
            focuselt === null || focuselt === void 0 ? void 0 : focuselt.blur();
            this.onSizeEnd();
        }
    };
    Sizer.prototype.updateSize = function (event, sizeChange, applyKeyboardMultiplier) {
        if (applyKeyboardMultiplier === void 0) { applyKeyboardMultiplier = false; }
        // Compute the udpated size of the Sized element.
        var currentSize = ObservableLike.getValue(this.props.size);
        var multiplier = this.props.position === Position.far ? -1 : 1;
        var keyboardStepMultiplier = applyKeyboardMultiplier ? this.props.keyboardStepMultiplier || 1 : 1;
        var updatedSize = Math.floor(Math.min(this.props.maxSize, Math.max(this.props.minSize, currentSize + sizeChange * multiplier * keyboardStepMultiplier)));
        this.props.onSize(event, updatedSize, this.props.id);
        // console.log("currentSize = " + currentSize + " updateSize = " + updatedSize);
        return (updatedSize - currentSize) * multiplier;
    };
    Sizer.defaultProps = {
        divider: true,
        maxSize: 10000,
        minSize: 100
    };
    return Sizer;
}(React.Component));
export { Sizer };
/**
 * The Sized function is used to produce a div that has a fixed width or height
 * based on the orientation of the sized props. This is a basic component that
 * can be used with the Sizer to produce a basic splitter like UI.
 *
 * @param props properties to render the appropriate container element given the
 * props.
 */
export function Sized(props) {
    return (React.createElement(Observer, { height: props.height, width: props.width }, function (observedProps) {
        var style = {};
        // Add any specific height that has been defined.
        if (observedProps.height !== undefined) {
            style.height = observedProps.height + "px";
        }
        // Add any specific width that has been defined.
        if (observedProps.width !== undefined) {
            style.width = observedProps.width + "px";
        }
        return (React.createElement("div", { className: css(props.className, "flex-noshrink"), style: style }, props.children));
    }));
}
